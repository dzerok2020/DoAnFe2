"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.analyzer = exports.TopScopeType = void 0;
const utils_1 = require("./utils");
// â‘ (ðŸŽ¯): Top-level scope statement types, it also means statements that can be converted
// é¡¶çº§ä½œç”¨äºŽè¯­å¥ç±»åž‹ï¼Œè¿™ç§å¯ä»¥è¢«æ— ç¼æ¢æˆ import
var TopScopeType;
(function (TopScopeType) {
    // require('foo')[.bar]
    TopScopeType["ExpressionStatement"] = "ExpressionStatement";
    // const bar = rquire('foo')[.bar]
    TopScopeType["VariableDeclaration"] = "VariableDeclaration";
})(TopScopeType = exports.TopScopeType || (exports.TopScopeType = {}));
/**
 * `require` statement analyzer
 * require è¯­æ³•åˆ†æžå™¨
 */
function analyzer(ast, code, id) {
    const analyzed = {
        ast,
        code,
        id,
        require: [],
        exports: [],
    };
    (0, utils_1.simpleWalk)(ast, {
        CallExpression(node, ancestors) {
            if (node.callee.name !== 'require')
                return;
            const dynamic = checkDynamicId(node);
            analyzed.require.push({
                node,
                ancestors,
                topScopeNode: dynamic === 'dynamic'
                    ? undefined
                    : findTopLevelScope(ancestors),
                dynamic: checkDynamicId(node),
            });
        },
        AssignmentExpression(node, ancestors) {
            if (node.left.type !== 'MemberExpression')
                return;
            if (!(node.left.object.type === 'Identifier' && ['module', 'exports'].includes(node.left.object.name)))
                return;
            analyzed.exports.push({
                node,
                token: {
                    left: node.left.object.name,
                    right: node.left.property.name,
                },
            });
        },
    });
    return analyzed;
}
exports.analyzer = analyzer;
function checkDynamicId(node) {
    var _a, _b, _c;
    if (((_a = node.arguments[0]) === null || _a === void 0 ? void 0 : _a.type) === 'TemplateLiteral' &&
        ((_b = node.arguments[0]) === null || _b === void 0 ? void 0 : _b.quasis.length) === 1) {
        // e.g. require(`@/foo/bar.js`)
        return 'Literal';
    }
    // Only `require` with one-argument is supported
    return ((_c = node.arguments[0]) === null || _c === void 0 ? void 0 : _c.type) !== 'Literal' ? 'dynamic' : undefined;
}
// At present, only the "MemberExpression" of the one-depth is considered as the top-level scope
// å½“å‰ï¼Œåªè®¤ä¸ºä¸€å±‚çš„ MemberExpression é¡¶çº§ä½œç”¨åŸŸ
// e.g.
//   âœ… require('foo').bar
//   âŒ require('foo').bar.baz
//
// Will be return nearset scope ancestor node (ðŸŽ¯-â‘ )
// è¿™å°†è¿”å›žæœ€è¿‘ä½œç”¨åŸŸçš„ç¥–å…ˆèŠ‚ç‚¹
function findTopLevelScope(ancestors) {
    const ances = ancestors.map(an => an.type).join();
    const arr = [...ancestors].reverse();
    if (/Program,ExpressionStatement,(MemberExpression,)?CallExpression$/.test(ances)) {
        // Program,ExpressionStatement,CallExpression                  | require('foo')
        // Program,ExpressionStatement,MemberExpression,CallExpression | require('foo').bar
        return arr.find(e => e.type === TopScopeType.ExpressionStatement);
    }
    // At present, "ancestors" contains only one depth of "MemberExpression"
    if (/Program,VariableDeclaration,VariableDeclarator,(MemberExpression,)?CallExpression$/.test(ances)) {
        // const bar = require('foo').bar
        // const { foo, bar: baz } = require('foo')
        return arr.find(e => e.type === TopScopeType.VariableDeclaration);
    }
}
